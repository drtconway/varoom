#include "varoom/kmers.hpp"
#include "varoom/util/murmur3.hpp"

#include <queue>
#include <unordered_set>
#include <iostream>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE kmer_accumulator tests
#include <boost/test/unit_test.hpp>

using namespace std;
using namespace varoom;

namespace // anonymous
{

    const string seq = R"(
>NC_012891.1 Streptococcus dysgalactiae partial sequence
AGTCTGTTTTTTTATTTCTACTTTTCCACAGTCTATTAGAAGCCTCTTCCCTTTATTGTCAAGGTTTTTTATTATTTCCA
CAGGCTGTGGAAAACTTTAGTTAACACTGTGAATTACCTTTCCACAACTTGTGGGTAACTATAACTATTCTTTCAGGTTT
TGTGGAAAACTGACTGGATTTGTGTTAAAATAGTCCTAGAATTATCCACAAGAAGGAACCTAGTATGACTGAAAATGAAC
AAATTTTTTGGAATCGGGTCTTGGAATTAGCTCAGAGCCAATTAAAACAGGCAACGTATGAATTTTTTGTGCATGATGCA
CGCTTATTAAAAGTTGAGAATCATGTGGCAACGATTTACTTAGATCAAATGAAAGAACTCTTTTGGGAAAAAAACCTTAA
AGATGTTATTCTGACAGCTGGTTTTGAAGTTTATAATGCTCAAATTGCCGTTGACTATGTTTTTGAAGAAGATCTGATAA
TTGACCAAAATCAAATCCCAAATAGCCAAAGCTACAATCAGCAAGTAATAACTCCTTTACCTGCTGTTACCTCAGACCTA
AATCCCAAATATAGTTTTGAAAACTTTATTCAGGGTGATGAAAATCGTTGGGCTGTAGCTGCTTCTATAGCAGTAGCTAA
TACACCAGGAACAACCTATAACCCTTTGTTTATCTGGGGAGGGCCTGGACTAGGAAAAACCCATTTGTTAAATGCCATTG
GAAACTCTGTGCTATTAGAAAATCCCAATGCCCGTATAAAGTACATCACCGCTGAAAATTTCATTAATGAATTTGTGATT
CATATTCGTTTAGACACTATGGACGAATTAAAAGAAAAGTTCCGTAATCTCGATTTACTGCTTATTGATGATATCCAATC
GCTGGCGAAGAAAACATTATCTGGAACACAAGAAGAGTTCTTTAATACTTTTAATGCTCTTCATAACAATAATAAACAAA
TCGTTCTAACCAGTGACCGCACACCAGATCACCTTAATGATTTAGAAGATCGATTGGTAACCCGTTTCAAATGGGGCTTA
ACCGTTAATATTACGCCTCCAGATTTTGAAACTCGAGTAGCTATCTTAACGAATAAAATTCAGGAATATAATTTTATTTT
CCCTCAAGATACTATTGAATATCTAGCTGGCCAATTCGATTCCAATGTGAGAGATTTGGAAGGCGCCTTAAAAGACATTA
GTTTGGTTGCTAATTTTAAGCAAATTGATACCATTACGGTTGACGTTGCTGCAGAAGCTATTCGTGCCAGAAAACAAGAT
GGACCTAAAATGACGGTCATTCCAATTGAAGAAATTCAAACGCAGGTTGGAAAATTCTATGACGTCACTGTCAAAGAAAT
TAAGGCAACTAAACGTACGCAAGATATTGTGTTAGCAAGACAAGTCGCTATGTTTTTAGCACGTGAAATGACAGATAATA
GCCTTCCCAAAATTGGTAAGGAATTTGGTGGTAGGGATCATTCCACTGTACTTCATGCCTACAATAAAATCAAAAACATG
ATTAGCCAGGATGAAAGCCTTCGTATTGAAATTGAAACCATCAAAAATAAAATTAAGTAGCTTGTGGACAAGTTCTATTT
TTAGTGACGAGTTATCCACAAGTTGTGAACAGTCTTCTTTCCTTATCCCTACTAGATAAATCAGACTTATCCACGTCATA
CACAAGACCTACTACTACTACTAATTATTATACTTATCAATAAAGGAGTCCTCATGATTCAATTTTCCATAAATCGTACC
CTTTTCATTCAAGCTTTAAATGCCACTAAACGTGGTATTAGCAGTAAAAATGCCATTCCTGTTCTTTCTACCATTAAGAT
TAACGTTAGTTCATCTGATATCACTTTAACTGGTTCAAATGGACAAATTTCAATTGAAAATACCATTCCTGTAAGCAATG
AAAATGCTGGACTATTAATCACATCTCCAGGGTCTATTCTTCTGGAAGCAAATTTCTTTATCAATATTATTTCTAGTTTG
CCAGATGTTAGTTTGGATTTTAAAGAAATTGAACAACATCAAGTTGTTTTAACCAGTGGTAAATCAGAAATTACCTTAAA
AGGAAAAGATGTTGATCAATACCCTCGGTTACAAGAAGTATCAACAGAAAATCCTTTGATCTTAAAAACAAAATTATTAA
AGTCTATTATTGCTGAAACAGCTTTTGCAGCCAGTTTACAAGAAAGTCGTCCTATCTTAACAGGAGTTCATATTGTATTA
AGTAACCATAAAGATTTTAAAGCCGTAGCAACTGACTCTCATCGTATGAGTCAACGTTTAATCACTTTGGATAATACTTC
AGCAGATTTTGATGTGGTTATTCCAAGTAAATCTTTGAGAGAATTTTCAGCAGTATTTACAGATGATATTGAGACTGTTG
AGGTATTTTTCTCACCAAGCCAAATCTTGTTCAGAAGTGAACATATTTCTTTCTATACACGTCTCTTAGAAGGAAATTAT
CCCGATACAGACCGTTTGTTAATGACACAATTTGAGACAGAGGTTGTTTTCAATACCCAATCTCTTCGCCACGCTATGGA
ACGTGCTTTCTTGATTTCGAACGCTACTCAAAATGGTACCGTTAAACTTGAAATTGCTCAAAATCATATTTCAGCTCATG
TTAACTCACCGGAAGTTGGTAAAGTAAACGAAGATTTGGATATTGTTAGTCAATCTGGTAGTGATTTAACTATTAGTTTC
AACCCAACTTACCTTATTGAATCTCTCAAGGCTATCAAGAGTGAAACAGTTAAAATTCATTTCTTGTCACCAGTACGACC
ATTTACCTTGACACCAGGTGATGATGAAGAAAGCTTTATCCAGTTAATCACACCAGTCCGTACCAACTAAAAAGAAAAGG
CTCCCTTTTAGGAGCTTTTTTTGTTATCATAAATGATGAAGATAATAAGAGTGAGGAAAAAAGATGTATCAAATTGGATC
ACTTGTTGAAATGAAAAAACCGCACGCCTGTGTGATTAAAGAGACTGGTAAAAAATCTAATCAATGGAAAGTGCTTAGAG
TAGGAGCTGATATTAAAATTCAATGCACTAACTGTCAGCACATCATTATGATGAGCCGTTACGACTTTGACCGAAAACTA
AAAAAAGTCCTGCAACTTTAGAAATATTGATTTAGTAGGCTTTCTTATACATCTTGCAACCAATACTTGCCTAAATAATT
GTTAGTATGCCTTTGGAAAATCAGGTATTCTAATGTTATCGAAAGAAGAAAGGTGGTCATAGAAAATGACAAAAGTTGCA
GAACAATTAAAGCAATTACGAGTGAAACATCAATTATCTCAAGATGCTCTGGCAGAACAGTTATTTATTTCTCGGCAAGC
CATATCAAAATGAGAAAATGGAGATACAATACCAGATTTGGATAATTTGGTCAGGTTAACTGAAATTTTTGACGTGAGCT
TAGATGAGCTTGTTTTAGCTAAACCACATGAAGTTAAAGTTGAACGCATTTATGAAAACAAACCGCTTGATCTACAAAAA
TACAATAAGCTCTATTGGTTTATTTTTCGAAATATTATTCTGTCTCTACTAATTATTTTAGCTATATTAACTATCTTAGA
AGTTTTAGGGATACCTTTTGTTTCTAATTGGTTAATTTAAAGAAAAGTTGAAGAGTAATATGATGCTAAGCGAACCTGAA
ATTTTCTTATCATCATACCGCTTTTTTCGTTTATTTTCTGTTATAATAGTTGTGATTGAAATTTTGAATGGAGACTTATT
AAAATGGCTTTAACAGCAGGTATTGTGGGCTTACCTAATGTTGGTAAATCAACTTTATTTAATGCAATTACAAAAGCAGG
GGCAGAAGCTGCTAATTATCCTTTTGCAACGATTGATCCTAATGTTGGGATGGTAGAGGTACCAGATGAACGTCTGCAAA
AATTGACAGAGTTGATTACGCCTAAAAAAACCGTTCCAACAACCTTTGAGTTTACTGATATTGCGGGTATTGTTAAAGGA
GCTTCTAAAGGAGAAGGGTTAGGTAATAAATTCTTGGCCAATATCCGTGAAGTAGATGCTATCGTACATGTCGTTCGTGC
TTTTGATGATGAAAATGTTATGCGTGAACAAGGTCGTGAGGATGCTTTCGTGGATCCAATGGCTGATATTGATACTATCA
ACCTTGAATTGATTTTGGCTGATTTAGAGTCTATTAATAAGCGTTATGCGCGTGTGGAAAAAATGGCTCGTACCCAAAAA
GATAAGGATTCCGTGGCAGAATTTGCCGTTCTTGAAAAAATCAAACCTGTCTTAGAAGATGGTAAATCTGCTCGGACAAT
)";

class minhash
{
public:
    struct hash_comparitor
    {
        bool operator()(const kmer& p_x, const kmer& p_y) const
        {
            uint32_t a = murmur3(19).update(p_x)();
            uint32_t b = murmur3(19).update(p_y)();
            return a < b;
        }
    };

    minhash(size_t p_max_size)
        : m_max_size(p_max_size)
    {
    }

    minhash& add(const kmer& p_x)
    {
        if (m_items.count(p_x) > 0)
        {
            return *this;
        }

        m_items.insert(p_x);
        m_queue.push(p_x);

        while (m_items.size() > m_max_size)
        {
            kmer x = m_queue.top();
            m_queue.pop();
            m_items.erase(x);
        }

        return *this;
    }

    const std::unordered_set<kmer>& items() const
    {
        return m_items;
    }

private:
    const size_t m_max_size;
    std::unordered_set<kmer> m_items;
    std::priority_queue<kmer, std::vector<kmer>, hash_comparitor> m_queue;
};

}
// namespace anonymous

BOOST_AUTO_TEST_CASE( cons )
{
    vector<kmer> fwd;
    vector<kmer> rev;
    const size_t K = 8;
    kmers::make(seq, K, fwd, rev);

    std::unordered_set<kmer> X;
    minhash H(100);

    for (size_t i = 0; i < fwd.size(); ++i)
    {
        kmer x = std::min(fwd[i], rev[i]);
        H.add(x);
        X.insert(x);
    }

    std::vector<kmer> xs(H.items().begin(), H.items().end());
    std::sort(xs.begin(), xs.end());

    std::vector<kmer> ys(X.begin(), X.end());
    BOOST_REQUIRE_EQUAL(X.size() >= xs.size(), true);

    std::sort(ys.begin(), ys.end(), minhash::hash_comparitor());
    std::sort(ys.begin(), ys.begin() + xs.size());

    for (size_t i = 0; i < xs.size(); ++i)
    {
        BOOST_CHECK_EQUAL(xs[i], ys[i]);
    }
}
